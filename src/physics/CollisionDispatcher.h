

#ifndef COMETA_COLLISION_DISPATCHER_H
#define COMETA_COLLISION_DISPATCHER_H

#include <glm.hpp>

// define the classes
class Transform;
class Collider;

/**
 * Point of contact between 2 colliders
 * Its calculated and generated by @class [CollisionDispatcher.h] []
 */
struct CollisionPoint
{
    glm::vec3 a;
    glm::vec3 b;
    glm::vec3 point;
    glm::vec3 normal;
    float length;
    bool collided;
};

using CollisionDispatchFunction = CollisionPoint(*)(const Collider*, const Transform*, const Collider*, const Transform*);

/**
 * @brief Class in charge of dispatching the collisions
 * Helps in the dispatching of the collision events
 * Uses a dispatch matrix to resolve collisions using different functions
 */
class CollisionDispatcher
{

private:
    /**
     * Dispatch matrix used for retrieving the correct function for resolving the collision
     * @typedef {CollisionPoint(*)(const Collider*, const Transform*, const Collider*, const Transform*);}
     */
    static CollisionDispatchFunction collisionDispatcher[2][2];

public:
    /**
     * Generates a collision point by interseting a Box and an Sphere.
     * Colliders need to be ordered by ColliderType, so the lower collider type value needs to be on collider and transform and the higher in otherCollider and otherTransform
     * @param collider Box collider
     * @param transform Box transform
     * @param otherCollider Sphere collider
     * @param otherTransform Sphere transform
     * @return CollisionPoint with colliding = false | true depending on if they overlap and the collision information.
     */
    static CollisionPoint IntersectBoxSphere(const Collider* collider, const Transform* transform, const Collider* otherCollider, const Transform* otherTransform);

    /**
     * Generates a collision point by intersecting two spheres
     * @param collider Sphere 1 collider
     * @param transform Sphere 1 collider
     * @param otherCollider Sphere 2 collider
     * @param otherTransform Sphere 2 transform
     * @return CollisionPoint containing colliding = true|false depending on if both spheres collide between then and the collision data
     */
    static CollisionPoint IntersectSphereSphere(const Collider* collider, const Transform* transform, const Collider* otherCollider, const Transform* otherTransform);

    /**
     * Generates a CollisionPoint intersecting two boxes. A collision point is created independently if they collision or not.
     * @param collider Box 1 collider
     * @param transform Box 1 transform
     * @param otherCollider Box 2 collider
     * @param otherTransform  Box 2 transform
     * @return CollisionPoint containing colliding = true|false depending on if both spheres collide between then and the collision data
     */
    static CollisionPoint IntersectBoxBox(const Collider* collider, const Transform* transform, const Collider* otherCollider, const Transform* otherTransform);

    /**
     * Dispatch a collision between two colliders. The colliders need to be ordered by ColliderType, so the lower one comes first in the arguments.
     * This function uses the CollisionDispatchFunction to determine the function (IntersectBoxBox, IntersectBoxSphere or IntersectSphereSphere) that need to be used to check for the CollisionPoint
     *
     * In case there are not Function implemented for that type of collider, it will return an empty CollisionPoint {}.
     * @param collider Collider component of the entity 1 to check
     * @param transform Transform of the entity 1 to check
     * @param otherCollider Collider component of the entity 2 to check
     * @param otherTransform Transform of the entity 2 to check.
     * @return CollisionPoint containing the data of the collision or intersection between two colliders. CollisionPoint is generated indepently if they collide or not.
     */
    static CollisionPoint Dispatch(const Collider* collider, const Transform* transform, const Collider* otherCollider, const Transform* otherTransform);
};


#endif //COMETA_COLLISION_DISPATCHER_H
